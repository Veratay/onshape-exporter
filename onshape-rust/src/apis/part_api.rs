/*
 * Onshape REST API
 *
 * ## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.
 *
 * The version of the OpenAPI document: 1.198.56658-8969b956ea73
 * Contact: api-support@onshape.zendesk.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`export_part_gltf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportPartGltfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_ps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportPsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_stl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportStlError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_bend_table`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBendTableError {
    DefaultResponse(models::BtTableResponse1546),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_body_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBodyDetailsError {
    DefaultResponse(models::BtExportModelBodiesResponse734),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_bounding_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBoundingBoxesError {
    DefaultResponse(models::BtBoundingBoxInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_edges`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEdgesError {
    DefaultResponse(models::BtExportTessellatedEdgesResponse327),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_faces1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFaces1Error {
    DefaultResponse(models::BtExportTessellatedFacesResponse898),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mass_properties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMassPropertiesError {
    DefaultResponse(models::BtMassPropertiesBulkInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_shaded_views`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartShadedViewsError {
    DefaultResponse(models::BtShadedViewsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_parts_wmv`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartsWmvError {
    DefaultResponse(Vec<models::BtPartMetadataInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_parts_wmve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartsWmveError {
    DefaultResponse(Vec<models::BtPartMetadataInfo>),
    UnknownValue(serde_json::Value),
}


/// Creates a synchronous export of the part (with limited tessellation settings) to a glTF file.  * Returns a 307 redirect from which to download the exported file.  * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.  * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.    See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
pub async fn export_part_gltf(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, angle_tolerance: Option<f64>, chord_tolerance: Option<f64>, precomputed_level_of_detail: Option<&str>, output_separate_face_nodes: Option<bool>, face_id: Option<Vec<String>>, output_face_appearances: Option<bool>, max_facet_width: Option<f64>) -> Result<models::GlTf, Error<ExportPartGltfError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_angle_tolerance = angle_tolerance;
    let p_chord_tolerance = chord_tolerance;
    let p_precomputed_level_of_detail = precomputed_level_of_detail;
    let p_output_separate_face_nodes = output_separate_face_nodes;
    let p_face_id = face_id;
    let p_output_face_appearances = output_face_appearances;
    let p_max_facet_width = max_facet_width;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/gltf", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_angle_tolerance {
        req_builder = req_builder.query(&[("angleTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chord_tolerance {
        req_builder = req_builder.query(&[("chordTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_precomputed_level_of_detail {
        req_builder = req_builder.query(&[("precomputedLevelOfDetail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_separate_face_nodes {
        req_builder = req_builder.query(&[("outputSeparateFaceNodes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_face_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("faceId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("faceId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_output_face_appearances {
        req_builder = req_builder.query(&[("outputFaceAppearances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_facet_width {
        req_builder = req_builder.query(&[("maxFacetWidth", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GlTf`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GlTf`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportPartGltfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a synchronous export of the part (with limited tessellation settings) to a Parasolid file.  * Returns a 307 redirect from which to download the exported file.  * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.  * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.    See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
pub async fn export_ps(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, version: Option<&str>, configuration2: Option<&str>, link_document_id: Option<&str>) -> Result<(), Error<ExportPsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_version = version;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/parasolid", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportPsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a synchronous export of the part (with limited tessellation settings) to an STL file.  * Returns a 307 redirect from which to download the exported file.  * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.  * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.    See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
pub async fn export_stl(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, mode: Option<&str>, grouping: Option<bool>, scale: Option<f64>, units: Option<&str>, angle_tolerance: Option<f64>, chord_tolerance: Option<f64>, max_facet_width: Option<f64>, min_facet_width: Option<f64>, configuration2: Option<&str>, link_document_id: Option<&str>) -> Result<serde_json::Value, Error<ExportStlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_mode = mode;
    let p_grouping = grouping;
    let p_scale = scale;
    let p_units = units;
    let p_angle_tolerance = angle_tolerance;
    let p_chord_tolerance = chord_tolerance;
    let p_max_facet_width = max_facet_width;
    let p_min_facet_width = min_facet_width;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/stl", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_grouping {
        req_builder = req_builder.query(&[("grouping", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scale {
        req_builder = req_builder.query(&[("scale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_units {
        req_builder = req_builder.query(&[("units", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_angle_tolerance {
        req_builder = req_builder.query(&[("angleTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chord_tolerance {
        req_builder = req_builder.query(&[("chordTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_facet_width {
        req_builder = req_builder.query(&[("maxFacetWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_facet_width {
        req_builder = req_builder.query(&[("minFacetWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportStlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_bend_table(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, link_document_id: Option<&str>) -> Result<models::BtTableResponse1546, Error<GetBendTableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/sheetmetal/bendtable", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtTableResponse1546`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtTableResponse1546`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBendTableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// All coordinates are in meters (m).
pub async fn get_body_details(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, include_geometric_data: Option<bool>) -> Result<models::BtExportModelBodiesResponse734, Error<GetBodyDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_include_geometric_data = include_geometric_data;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/bodydetails", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_geometric_data {
        req_builder = req_builder.query(&[("includeGeometricData", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtExportModelBodiesResponse734`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtExportModelBodiesResponse734`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBodyDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_bounding_boxes(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, include_hidden: Option<bool>, configuration2: Option<&str>, link_document_id: Option<&str>) -> Result<models::BtBoundingBoxInfo, Error<GetBoundingBoxesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_include_hidden = include_hidden;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/boundingboxes", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_hidden {
        req_builder = req_builder.query(&[("includeHidden", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtBoundingBoxInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtBoundingBoxInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBoundingBoxesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the coordinates (in meters) of each edge's endpoints.
pub async fn get_edges(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, angle_tolerance: Option<f64>, chord_tolerance: Option<f64>, precomputed_level_of_detail: Option<&str>, edge_id: Option<Vec<String>>) -> Result<models::BtExportTessellatedEdgesResponse327, Error<GetEdgesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_angle_tolerance = angle_tolerance;
    let p_chord_tolerance = chord_tolerance;
    let p_precomputed_level_of_detail = precomputed_level_of_detail;
    let p_edge_id = edge_id;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/tessellatededges", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_angle_tolerance {
        req_builder = req_builder.query(&[("angleTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chord_tolerance {
        req_builder = req_builder.query(&[("chordTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_precomputed_level_of_detail {
        req_builder = req_builder.query(&[("precomputedLevelOfDetail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_edge_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("edgeId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("edgeId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtExportTessellatedEdgesResponse327`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtExportTessellatedEdgesResponse327`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEdgesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Coordinates are in meters (m).
pub async fn get_faces1(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, angle_tolerance: Option<f64>, chord_tolerance: Option<f64>, precomputed_level_of_detail: Option<&str>, face_id: Option<Vec<String>>, output_face_appearances: Option<bool>, max_facet_width: Option<f64>, output_vertex_normals: Option<bool>, output_facet_normals: Option<bool>, output_texture_coordinates: Option<bool>, output_index_table: Option<bool>, output_error_faces: Option<bool>, combine_composite_part_constituents: Option<bool>) -> Result<models::BtExportTessellatedFacesResponse898, Error<GetFaces1Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_angle_tolerance = angle_tolerance;
    let p_chord_tolerance = chord_tolerance;
    let p_precomputed_level_of_detail = precomputed_level_of_detail;
    let p_face_id = face_id;
    let p_output_face_appearances = output_face_appearances;
    let p_max_facet_width = max_facet_width;
    let p_output_vertex_normals = output_vertex_normals;
    let p_output_facet_normals = output_facet_normals;
    let p_output_texture_coordinates = output_texture_coordinates;
    let p_output_index_table = output_index_table;
    let p_output_error_faces = output_error_faces;
    let p_combine_composite_part_constituents = combine_composite_part_constituents;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/tessellatedfaces", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_angle_tolerance {
        req_builder = req_builder.query(&[("angleTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chord_tolerance {
        req_builder = req_builder.query(&[("chordTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_precomputed_level_of_detail {
        req_builder = req_builder.query(&[("precomputedLevelOfDetail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_face_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("faceId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("faceId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_output_face_appearances {
        req_builder = req_builder.query(&[("outputFaceAppearances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_facet_width {
        req_builder = req_builder.query(&[("maxFacetWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_vertex_normals {
        req_builder = req_builder.query(&[("outputVertexNormals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_facet_normals {
        req_builder = req_builder.query(&[("outputFacetNormals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_texture_coordinates {
        req_builder = req_builder.query(&[("outputTextureCoordinates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_index_table {
        req_builder = req_builder.query(&[("outputIndexTable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_error_faces {
        req_builder = req_builder.query(&[("outputErrorFaces", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_combine_composite_part_constituents {
        req_builder = req_builder.query(&[("combineCompositePartConstituents", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtExportTessellatedFacesResponse898`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtExportTessellatedFacesResponse898`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFaces1Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Parts must have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-ps.htm).  When three values are returned:   * The first is the calculated value.   * The second is the minimum possible value, considering tolerance.   * The third is the maximum possible value, considering tolerance.
pub async fn get_mass_properties(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, infer_metadata_owner: Option<bool>, use_mass_property_overrides: Option<bool>) -> Result<models::BtMassPropertiesBulkInfo, Error<GetMassPropertiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_infer_metadata_owner = infer_metadata_owner;
    let p_use_mass_property_overrides = use_mass_property_overrides;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/massproperties", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_infer_metadata_owner {
        req_builder = req_builder.query(&[("inferMetadataOwner", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_mass_property_overrides {
        req_builder = req_builder.query(&[("useMassPropertyOverrides", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtMassPropertiesBulkInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtMassPropertiesBulkInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMassPropertiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_part_shaded_views(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, partid: &str, view_matrix: Option<&str>, output_height: Option<i32>, output_width: Option<i32>, pixel_size: Option<f64>, edges: Option<&str>, use_anti_aliasing: Option<bool>, configuration2: Option<&str>, link_document_id: Option<&str>) -> Result<models::BtShadedViewsInfo, Error<GetPartShadedViewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_partid = partid;
    let p_view_matrix = view_matrix;
    let p_output_height = output_height;
    let p_output_width = output_width;
    let p_pixel_size = pixel_size;
    let p_edges = edges;
    let p_use_anti_aliasing = use_anti_aliasing;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}/partid/{partid}/shadedviews", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid), partid=crate::apis::urlencode(p_partid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_view_matrix {
        req_builder = req_builder.query(&[("viewMatrix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_height {
        req_builder = req_builder.query(&[("outputHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_width {
        req_builder = req_builder.query(&[("outputWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pixel_size {
        req_builder = req_builder.query(&[("pixelSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_edges {
        req_builder = req_builder.query(&[("edges", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_anti_aliasing {
        req_builder = req_builder.query(&[("useAntiAliasing", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtShadedViewsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtShadedViewsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartShadedViewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_parts_wmv(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, element_id: &str, link_document_id: Option<&str>, configuration2: Option<&str>, with_thumbnails: Option<bool>, include_property_defaults: Option<bool>, include_flat_parts: Option<bool>) -> Result<Vec<models::BtPartMetadataInfo>, Error<GetPartsWmvError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_element_id = element_id;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_with_thumbnails = with_thumbnails;
    let p_include_property_defaults = include_property_defaults;
    let p_include_flat_parts = include_flat_parts;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("elementId", &p_element_id.to_string())]);
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_thumbnails {
        req_builder = req_builder.query(&[("withThumbnails", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_property_defaults {
        req_builder = req_builder.query(&[("includePropertyDefaults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_flat_parts {
        req_builder = req_builder.query(&[("includeFlatParts", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtPartMetadataInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtPartMetadataInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartsWmvError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_parts_wmve(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, with_thumbnails: Option<bool>, include_property_defaults: Option<bool>, include_flat_parts: Option<bool>, configuration2: Option<&str>, link_document_id: Option<&str>) -> Result<Vec<models::BtPartMetadataInfo>, Error<GetPartsWmveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_with_thumbnails = with_thumbnails;
    let p_include_property_defaults = include_property_defaults;
    let p_include_flat_parts = include_flat_parts;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/parts/d/{did}/{wvm}/{wvmid}/e/{eid}", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_with_thumbnails {
        req_builder = req_builder.query(&[("withThumbnails", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_property_defaults {
        req_builder = req_builder.query(&[("includePropertyDefaults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_flat_parts {
        req_builder = req_builder.query(&[("includeFlatParts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtPartMetadataInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtPartMetadataInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartsWmveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

