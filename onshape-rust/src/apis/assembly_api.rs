/*
 * Onshape REST API
 *
 * ## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.
 *
 * The version of the OpenAPI document: 1.198.56658-8969b956ea73
 * Contact: api-support@onshape.zendesk.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_feature`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddFeatureError {
    DefaultResponse(models::BtFeatureDefinitionResponse1617),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_assembly`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAssemblyError {
    DefaultResponse(models::BtDocumentElementInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateInstanceError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_feature`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFeatureError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_instance`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteInstanceError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_assembly_bounding_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssemblyBoundingBoxesError {
    DefaultResponse(models::BtBoundingBoxInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_assembly_definition`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssemblyDefinitionError {
    DefaultResponse(models::BtAssemblyDefinitionInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_assembly_mass_properties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssemblyMassPropertiesError {
    DefaultResponse(models::BtMassPropertiesInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_assembly_shaded_views`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAssemblyShadedViewsError {
    DefaultResponse(models::BtShadedViewsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_bill_of_materials`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBillOfMaterialsError {
    DefaultResponse(models::BtBillOfMaterialsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_display_states`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDisplayStatesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_exploded_views`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetExplodedViewsError {
    DefaultResponse(Vec<models::BtViewFeatureBaseInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_feature_specs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFeatureSpecsError {
    DefaultResponse(models::BtFeatureSpecsResponse664),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_features`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFeaturesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_mate_values`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMateValuesError {
    DefaultResponse(models::BtAssemblyMateValuesInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_named_positions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNamedPositionsError {
    DefaultResponse(Vec<models::BtViewFeatureBaseInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_named_views`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetNamedViewsError {
    DefaultResponse(models::BtNamedViewsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_or_create_bill_of_materials_element`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOrCreateBillOfMaterialsElementError {
    DefaultResponse(models::BtDocumentElementInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`insert_transformed_instances`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InsertTransformedInstancesError {
    DefaultResponse(models::BtAssemblyInsertTransformedInstancesResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`modify`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ModifyError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`transform_occurrences`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransformOccurrencesError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`translate_format`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TranslateFormatError {
    DefaultResponse(models::BtTranslationRequestInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_feature`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFeatureError {
    DefaultResponse(models::BtFeatureDefinitionResponse1617),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_mate_values`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMateValuesError {
    DefaultResponse(models::BtAssemblyMateValuesInfo),
    UnknownValue(serde_json::Value),
}


pub async fn add_feature(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, bt_feature_definition_call1406: Option<models::BtFeatureDefinitionCall1406>) -> Result<models::BtFeatureDefinitionResponse1617, Error<AddFeatureError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_bt_feature_definition_call1406 = bt_feature_definition_call1406;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/features", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_feature_definition_call1406);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureDefinitionResponse1617`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureDefinitionResponse1617`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddFeatureError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_assembly(configuration: &configuration::Configuration, did: &str, wid: &str, bt_model_element_params: models::BtModelElementParams) -> Result<models::BtDocumentElementInfo, Error<CreateAssemblyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_model_element_params = bt_model_element_params;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_model_element_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtDocumentElementInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtDocumentElementInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAssemblyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Part Studio instances may include multiple parts.
pub async fn create_instance(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, bt_assembly_instance_definition_params: Option<models::BtAssemblyInstanceDefinitionParams>) -> Result<serde_json::Value, Error<CreateInstanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_bt_assembly_instance_definition_params = bt_assembly_instance_definition_params;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/instances", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_assembly_instance_definition_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateInstanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_feature(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, fid: &str) -> Result<models::BtFeatureApiBase1430, Error<DeleteFeatureError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_fid = fid;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid), fid=crate::apis::urlencode(p_fid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureApiBase1430`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureApiBase1430`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFeatureError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_instance(configuration: &configuration::Configuration, did: &str, eid: &str, wid: &str, nid: &str) -> Result<serde_json::Value, Error<DeleteInstanceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wid = wid;
    let p_nid = nid;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/instance/nodeid/{nid}", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wid=crate::apis::urlencode(p_wid), nid=crate::apis::urlencode(p_nid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteInstanceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_assembly_bounding_boxes(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, exploded_view_id: Option<&str>, include_hidden: Option<bool>, display_state_id: Option<&str>, named_position_id: Option<&str>, include_sketches: Option<bool>) -> Result<models::BtBoundingBoxInfo, Error<GetAssemblyBoundingBoxesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_exploded_view_id = exploded_view_id;
    let p_include_hidden = include_hidden;
    let p_display_state_id = display_state_id;
    let p_named_position_id = named_position_id;
    let p_include_sketches = include_sketches;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/boundingboxes", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exploded_view_id {
        req_builder = req_builder.query(&[("explodedViewId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_hidden {
        req_builder = req_builder.query(&[("includeHidden", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_display_state_id {
        req_builder = req_builder.query(&[("displayStateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_named_position_id {
        req_builder = req_builder.query(&[("namedPositionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_sketches {
        req_builder = req_builder.query(&[("includeSketches", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtBoundingBoxInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtBoundingBoxInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssemblyBoundingBoxesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// All coordinates and translation matrix components are in meters (m).
pub async fn get_assembly_definition(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, exploded_view_id: Option<&str>, include_mate_features: Option<bool>, include_non_solids: Option<bool>, include_mate_connectors: Option<bool>, exclude_suppressed: Option<bool>) -> Result<models::BtAssemblyDefinitionInfo, Error<GetAssemblyDefinitionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_exploded_view_id = exploded_view_id;
    let p_include_mate_features = include_mate_features;
    let p_include_non_solids = include_non_solids;
    let p_include_mate_connectors = include_mate_connectors;
    let p_exclude_suppressed = exclude_suppressed;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exploded_view_id {
        req_builder = req_builder.query(&[("explodedViewId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_mate_features {
        req_builder = req_builder.query(&[("includeMateFeatures", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_non_solids {
        req_builder = req_builder.query(&[("includeNonSolids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_mate_connectors {
        req_builder = req_builder.query(&[("includeMateConnectors", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_suppressed {
        req_builder = req_builder.query(&[("excludeSuppressed", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAssemblyDefinitionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAssemblyDefinitionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssemblyDefinitionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The assembly must contain parts that have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-asmb.htm).  When three values are returned:   * The first is the calculated value.   * The second is the minimum possible value, considering tolerance.   * The third is the maximum possible value, considering tolerance.
pub async fn get_assembly_mass_properties(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>) -> Result<models::BtMassPropertiesInfo, Error<GetAssemblyMassPropertiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/massproperties", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtMassPropertiesInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtMassPropertiesInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssemblyMassPropertiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_assembly_shaded_views(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, exploded_view_id: Option<&str>, view_matrix: Option<&str>, output_height: Option<i32>, output_width: Option<i32>, pixel_size: Option<f64>, edges: Option<&str>, show_all_parts: Option<bool>, include_surfaces: Option<bool>, use_anti_aliasing: Option<bool>, include_wires: Option<bool>, display_state_id: Option<&str>, named_position_id: Option<&str>) -> Result<models::BtShadedViewsInfo, Error<GetAssemblyShadedViewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_exploded_view_id = exploded_view_id;
    let p_view_matrix = view_matrix;
    let p_output_height = output_height;
    let p_output_width = output_width;
    let p_pixel_size = pixel_size;
    let p_edges = edges;
    let p_show_all_parts = show_all_parts;
    let p_include_surfaces = include_surfaces;
    let p_use_anti_aliasing = use_anti_aliasing;
    let p_include_wires = include_wires;
    let p_display_state_id = display_state_id;
    let p_named_position_id = named_position_id;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/shadedviews", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exploded_view_id {
        req_builder = req_builder.query(&[("explodedViewId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_view_matrix {
        req_builder = req_builder.query(&[("viewMatrix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_height {
        req_builder = req_builder.query(&[("outputHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_width {
        req_builder = req_builder.query(&[("outputWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pixel_size {
        req_builder = req_builder.query(&[("pixelSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_edges {
        req_builder = req_builder.query(&[("edges", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_show_all_parts {
        req_builder = req_builder.query(&[("showAllParts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_surfaces {
        req_builder = req_builder.query(&[("includeSurfaces", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_anti_aliasing {
        req_builder = req_builder.query(&[("useAntiAliasing", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_wires {
        req_builder = req_builder.query(&[("includeWires", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_display_state_id {
        req_builder = req_builder.query(&[("displayStateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_named_position_id {
        req_builder = req_builder.query(&[("namedPositionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtShadedViewsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtShadedViewsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAssemblyShadedViewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the BOM in JSON in the Onshape BOM Standard format.
pub async fn get_bill_of_materials(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, bom_column_ids: Option<Vec<String>>, indented: Option<bool>, multi_level: Option<bool>, generate_if_absent: Option<bool>, template_id: Option<&str>, include_excluded: Option<bool>, only_visible_columns: Option<bool>, ignore_subassembly_bom_behavior: Option<bool>, include_item_microversions: Option<bool>, include_top_level_assembly_row: Option<bool>, thumbnail: Option<bool>) -> Result<models::BtBillOfMaterialsInfo, Error<GetBillOfMaterialsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_bom_column_ids = bom_column_ids;
    let p_indented = indented;
    let p_multi_level = multi_level;
    let p_generate_if_absent = generate_if_absent;
    let p_template_id = template_id;
    let p_include_excluded = include_excluded;
    let p_only_visible_columns = only_visible_columns;
    let p_ignore_subassembly_bom_behavior = ignore_subassembly_bom_behavior;
    let p_include_item_microversions = include_item_microversions;
    let p_include_top_level_assembly_row = include_top_level_assembly_row;
    let p_thumbnail = thumbnail;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/bom", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_bom_column_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("bomColumnIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("bomColumnIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_indented {
        req_builder = req_builder.query(&[("indented", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_multi_level {
        req_builder = req_builder.query(&[("multiLevel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_generate_if_absent {
        req_builder = req_builder.query(&[("generateIfAbsent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_template_id {
        req_builder = req_builder.query(&[("templateId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_excluded {
        req_builder = req_builder.query(&[("includeExcluded", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_only_visible_columns {
        req_builder = req_builder.query(&[("onlyVisibleColumns", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ignore_subassembly_bom_behavior {
        req_builder = req_builder.query(&[("ignoreSubassemblyBomBehavior", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_item_microversions {
        req_builder = req_builder.query(&[("includeItemMicroversions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_top_level_assembly_row {
        req_builder = req_builder.query(&[("includeTopLevelAssemblyRow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_thumbnail {
        req_builder = req_builder.query(&[("thumbnail", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtBillOfMaterialsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtBillOfMaterialsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBillOfMaterialsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_display_states(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>) -> Result<Vec<models::BtDisplayStateInfo>, Error<GetDisplayStatesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/displaystates", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtDisplayStateInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtDisplayStateInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDisplayStatesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_exploded_views(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, exploded_view_id: Option<&str>) -> Result<Vec<models::BtViewFeatureBaseInfo>, Error<GetExplodedViewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_exploded_view_id = exploded_view_id;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/explodedviews", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exploded_view_id {
        req_builder = req_builder.query(&[("explodedViewId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtViewFeatureBaseInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtViewFeatureBaseInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetExplodedViewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_feature_specs(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str) -> Result<models::BtFeatureSpecsResponse664, Error<GetFeatureSpecsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/featurespecs", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureSpecsResponse664`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureSpecsResponse664`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFeatureSpecsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_features(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, exploded_view_id: Option<&str>, feature_id: Option<Vec<String>>) -> Result<models::BtAssemblyFeatureListResponse1174, Error<GetFeaturesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_exploded_view_id = exploded_view_id;
    let p_feature_id = feature_id;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/features", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exploded_view_id {
        req_builder = req_builder.query(&[("explodedViewId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_feature_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("featureId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("featureId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAssemblyFeatureListResponse1174`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAssemblyFeatureListResponse1174`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFeaturesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Describes the relative position of the first mate connector with respect to the second along the designated degrees of freedom (DOF) for mates in the specified assembly.
pub async fn get_mate_values(configuration: &configuration::Configuration, did: &str, wv: &str, wvid: &str, eid: &str) -> Result<models::BtAssemblyMateValuesInfo, Error<GetMateValuesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wv = wv;
    let p_wvid = wvid;
    let p_eid = eid;

    let uri_str = format!("{}/assemblies/d/{did}/{wv}/{wvid}/e/{eid}/matevalues", configuration.base_path, did=crate::apis::urlencode(p_did), wv=crate::apis::urlencode(p_wv), wvid=crate::apis::urlencode(p_wvid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAssemblyMateValuesInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAssemblyMateValuesInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMateValuesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_named_positions(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, exploded_view_id: Option<&str>) -> Result<Vec<models::BtViewFeatureBaseInfo>, Error<GetNamedPositionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_exploded_view_id = exploded_view_id;

    let uri_str = format!("{}/assemblies/d/{did}/{wvm}/{wvmid}/e/{eid}/namedpositions", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exploded_view_id {
        req_builder = req_builder.query(&[("explodedViewId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtViewFeatureBaseInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtViewFeatureBaseInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNamedPositionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_named_views(configuration: &configuration::Configuration, did: &str, eid: &str, link_document_id: Option<&str>, skip_perspective: Option<bool>, include_section_cut_views: Option<bool>) -> Result<models::BtNamedViewsInfo, Error<GetNamedViewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_skip_perspective = skip_perspective;
    let p_include_section_cut_views = include_section_cut_views;

    let uri_str = format!("{}/assemblies/d/{did}/e/{eid}/namedViews", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_perspective {
        req_builder = req_builder.query(&[("skipPerspective", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_section_cut_views {
        req_builder = req_builder.query(&[("includeSectionCutViews", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtNamedViewsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtNamedViewsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetNamedViewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_or_create_bill_of_materials_element(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str) -> Result<models::BtDocumentElementInfo, Error<GetOrCreateBillOfMaterialsElementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/bomelement", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtDocumentElementInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtDocumentElementInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOrCreateBillOfMaterialsElementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn insert_transformed_instances(configuration: &configuration::Configuration, did: &str, eid: &str, wid: &str, bt_assembly_transformed_instances_definition_params: models::BtAssemblyTransformedInstancesDefinitionParams) -> Result<models::BtAssemblyInsertTransformedInstancesResponse, Error<InsertTransformedInstancesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wid = wid;
    let p_bt_assembly_transformed_instances_definition_params = bt_assembly_transformed_instances_definition_params;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/transformedinstances", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_assembly_transformed_instances_definition_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAssemblyInsertTransformedInstancesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAssemblyInsertTransformedInstancesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InsertTransformedInstancesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint can include multiple modifications to an assembly with one change. For example, it can delete/suppress/unsuppress/transform multiple instances. It creates one history entry in the document history list.
pub async fn modify(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, link_document_id: Option<&str>, bt_assembly_modification_params: Option<models::BtAssemblyModificationParams>) -> Result<serde_json::Value, Error<ModifyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_bt_assembly_modification_params = bt_assembly_modification_params;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/modify", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_assembly_modification_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ModifyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn transform_occurrences(configuration: &configuration::Configuration, did: &str, eid: &str, wid: &str, bt_assembly_transform_definition_params: Option<models::BtAssemblyTransformDefinitionParams>) -> Result<serde_json::Value, Error<TransformOccurrencesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wid = wid;
    let p_bt_assembly_transform_definition_params = bt_assembly_transform_definition_params;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/occurrencetransforms", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_assembly_transform_definition_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TransformOccurrencesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// * Use `formatName` in the JSON request body to specify the export file type. Use [Translations/getAllTranslatorFormats](https://cad.onshape.com/glassworks/explorer/#/Translation/getAllTranslatorFormats) to get a list of valid export file formats. Confirm that `couldBeAssembly=true.` * Set `storeInDocument` to `false` to export to a data file. Set to `true` to export to a blob element in the same document.  * See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details.
pub async fn translate_format(configuration: &configuration::Configuration, did: &str, wv: &str, wvid: &str, eid: &str, bt_translate_format_params: models::BtTranslateFormatParams) -> Result<models::BtTranslationRequestInfo, Error<TranslateFormatError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wv = wv;
    let p_wvid = wvid;
    let p_eid = eid;
    let p_bt_translate_format_params = bt_translate_format_params;

    let uri_str = format!("{}/assemblies/d/{did}/{wv}/{wvid}/e/{eid}/translations", configuration.base_path, did=crate::apis::urlencode(p_did), wv=crate::apis::urlencode(p_wv), wvid=crate::apis::urlencode(p_wvid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_translate_format_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtTranslationRequestInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtTranslationRequestInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TranslateFormatError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_feature(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, fid: &str, bt_feature_definition_call1406: Option<models::BtFeatureDefinitionCall1406>) -> Result<models::BtFeatureDefinitionResponse1617, Error<UpdateFeatureError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_fid = fid;
    let p_bt_feature_definition_call1406 = bt_feature_definition_call1406;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid), fid=crate::apis::urlencode(p_fid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_feature_definition_call1406);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureDefinitionResponse1617`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureDefinitionResponse1617`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateFeatureError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// * The input mates must support motion along the provided input degrees of freedom; otherwise, the input mate value will be ignored.  * Values associated with multiple allowed degrees of freedom for a mate can be updated simultaneously.  * Values associated with multiple mate features can be updated simultaneously.
pub async fn update_mate_values(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, bt_assembly_mate_values_info: models::BtAssemblyMateValuesInfo) -> Result<models::BtAssemblyMateValuesInfo, Error<UpdateMateValuesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_bt_assembly_mate_values_info = bt_assembly_mate_values_info;

    let uri_str = format!("{}/assemblies/d/{did}/w/{wid}/e/{eid}/matevalues", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_assembly_mate_values_info);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAssemblyMateValuesInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAssemblyMateValuesInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateMateValuesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

