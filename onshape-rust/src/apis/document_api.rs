/*
 * Onshape REST API
 *
 * ## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.
 *
 * The version of the OpenAPI document: 1.198.56658-8969b956ea73
 * Contact: api-support@onshape.zendesk.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`copy_workspace`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopyWorkspaceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDocumentError {
    DefaultResponse(models::BtDocumentInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVersionError {
    DefaultResponse(models::BtVersionInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_workspace`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWorkspaceError {
    DefaultResponse(models::BtWorkspaceInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_workspace`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWorkspaceError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_external_data`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadExternalDataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export2_json`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum Export2JsonError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_current_microversion`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCurrentMicroversionError {
    DefaultResponse(models::BtMicroversionInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document_acl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentAclError {
    DefaultResponse(models::BtAclInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentHistoryError {
    DefaultResponse(Vec<models::BtDocumentHistoryInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document_permission_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentPermissionSetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document_versions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentVersionsError {
    DefaultResponse(Vec<models::BtVersionInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document_workspaces`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentWorkspacesError {
    DefaultResponse(Vec<models::BtWorkspaceInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_elements_in_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetElementsInDocumentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_insertables`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetInsertablesError {
    DefaultResponse(models::BtInsertablesListResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_unit_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUnitInfoError {
    DefaultResponse(models::BtUnitInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetVersionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`merge_into_workspace`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MergeIntoWorkspaceError {
    DefaultResponse(models::BtDocumentMergeInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`merge_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MergePreviewError {
    DefaultResponse(models::BtMergePreviewInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`move_elements_to_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MoveElementsToDocumentError {
    DefaultResponse(models::BtMoveElementInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`restore_from_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestoreFromHistoryError {
    DefaultResponse(models::BtRestoreFromHistoryInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revert_unchanged_to_revisions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevertUnchangedToRevisionsError {
    DefaultResponse(Vec<models::BtUnchangedElementInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`share_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ShareDocumentError {
    DefaultResponse(models::BtAclInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`share_with_support`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ShareWithSupportError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sync_app_elements`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SyncAppElementsError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`un_share_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnShareDocumentError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unshare_from_support`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnshareFromSupportError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_anonymous_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAnonymousAccessError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_document_attributes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentAttributesError {
    DefaultResponse(models::BtDocumentSummaryInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_external_references_to_latest_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateExternalReferencesToLatestDocumentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_public_access`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePublicAccessError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}


pub async fn copy_workspace(configuration: &configuration::Configuration, did: &str, wid: &str, bt_copy_document_params: models::BtCopyDocumentParams) -> Result<models::BtCopyDocumentInfo, Error<CopyWorkspaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_copy_document_params = bt_copy_document_params;

    let uri_str = format!("{}/documents/{did}/workspaces/{wid}/copy", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_copy_document_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtCopyDocumentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtCopyDocumentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CopyWorkspaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The `name` field is required in the `BTDocumentParams` schema when creating a new document.
pub async fn create_document(configuration: &configuration::Configuration, bt_document_params: models::BtDocumentParams) -> Result<models::BtDocumentInfo, Error<CreateDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_bt_document_params = bt_document_params;

    let uri_str = format!("{}/documents", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_document_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtDocumentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtDocumentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_version(configuration: &configuration::Configuration, did: &str, bt_version_or_workspace_params: models::BtVersionOrWorkspaceParams) -> Result<models::BtVersionInfo, Error<CreateVersionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_bt_version_or_workspace_params = bt_version_or_workspace_params;

    let uri_str = format!("{}/documents/d/{did}/versions", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_version_or_workspace_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtVersionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtVersionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateVersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_workspace(configuration: &configuration::Configuration, did: &str, bt_version_or_workspace_params: Option<models::BtVersionOrWorkspaceParams>) -> Result<models::BtWorkspaceInfo, Error<CreateWorkspaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_bt_version_or_workspace_params = bt_version_or_workspace_params;

    let uri_str = format!("{}/documents/d/{did}/workspaces", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_version_or_workspace_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtWorkspaceInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtWorkspaceInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateWorkspaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_document(configuration: &configuration::Configuration, did: &str, forever: Option<bool>) -> Result<serde_json::Value, Error<DeleteDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_forever = forever;

    let uri_str = format!("{}/documents/{did}", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_forever {
        req_builder = req_builder.query(&[("forever", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_workspace(configuration: &configuration::Configuration, did: &str, wid: &str) -> Result<serde_json::Value, Error<DeleteWorkspaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;

    let uri_str = format!("{}/documents/d/{did}/workspaces/{wid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWorkspaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// * See [API Guide: Model Translation](https://onshape-public.github.io/docs/api-adv/translation/) for more details. * If downloading an exported file, poll the `requestState` in the translation response and wait for a result of `DONE` before attempting to download the file.  * Use the `resultExternalDataIds` from the translation response as the foreign id (`{fid}`) in this API.
pub async fn download_external_data(configuration: &configuration::Configuration, did: &str, fid: &str, if_none_match: Option<&str>) -> Result<reqwest::Response, Error<DownloadExternalDataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_fid = fid;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/documents/d/{did}/externaldata/{fid}", configuration.base_path, did=crate::apis::urlencode(p_did), fid=crate::apis::urlencode(p_fid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadExternalDataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn export2_json(configuration: &configuration::Configuration, did: &str, wv: &str, wvid: &str, eid: &str, link_document_id: Option<&str>, btb_export_model_params: Option<models::BtbExportModelParams>) -> Result<serde_json::Value, Error<Export2JsonError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wv = wv;
    let p_wvid = wvid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_btb_export_model_params = btb_export_model_params;

    let uri_str = format!("{}/documents/d/{did}/{wv}/{wvid}/e/{eid}/export", configuration.base_path, did=crate::apis::urlencode(p_did), wv=crate::apis::urlencode(p_wv), wvid=crate::apis::urlencode(p_wvid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_btb_export_model_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<Export2JsonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_current_microversion(configuration: &configuration::Configuration, did: &str, wv: &str, wvid: &str) -> Result<models::BtMicroversionInfo, Error<GetCurrentMicroversionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wv = wv;
    let p_wvid = wvid;

    let uri_str = format!("{}/documents/d/{did}/{wv}/{wvid}/currentmicroversion", configuration.base_path, did=crate::apis::urlencode(p_did), wv=crate::apis::urlencode(p_wv), wvid=crate::apis::urlencode(p_wvid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtMicroversionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtMicroversionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCurrentMicroversionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_document(configuration: &configuration::Configuration, did: &str) -> Result<models::BtDocumentInfo, Error<GetDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;

    let uri_str = format!("{}/documents/{did}", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtDocumentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtDocumentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_document_acl(configuration: &configuration::Configuration, did: &str) -> Result<models::BtAclInfo, Error<GetDocumentAclError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;

    let uri_str = format!("{}/documents/{did}/acl", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAclInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAclInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentAclError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_document_history(configuration: &configuration::Configuration, did: &str, wm: &str, wmid: &str) -> Result<Vec<models::BtDocumentHistoryInfo>, Error<GetDocumentHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wm = wm;
    let p_wmid = wmid;

    let uri_str = format!("{}/documents/d/{did}/{wm}/{wmid}/documenthistory", configuration.base_path, did=crate::apis::urlencode(p_did), wm=crate::apis::urlencode(p_wm), wmid=crate::apis::urlencode(p_wmid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtDocumentHistoryInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtDocumentHistoryInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_document_permission_set(configuration: &configuration::Configuration, did: &str) -> Result<Vec<String>, Error<GetDocumentPermissionSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;

    let uri_str = format!("{}/documents/{did}/permissionset", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentPermissionSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_document_versions(configuration: &configuration::Configuration, did: &str, offset: Option<i32>, limit: Option<i32>) -> Result<Vec<models::BtVersionInfo>, Error<GetDocumentVersionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_offset = offset;
    let p_limit = limit;

    let uri_str = format!("{}/documents/d/{did}/versions", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtVersionInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtVersionInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentVersionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_document_workspaces(configuration: &configuration::Configuration, did: &str) -> Result<Vec<models::BtWorkspaceInfo>, Error<GetDocumentWorkspacesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;

    let uri_str = format!("{}/documents/d/{did}/workspaces", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtWorkspaceInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtWorkspaceInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentWorkspacesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_documents(configuration: &configuration::Configuration, q: Option<&str>, filter: Option<i32>, owner: Option<&str>, owner_type: Option<i32>, sort_column: Option<&str>, sort_order: Option<&str>, offset: Option<i32>, limit: Option<i32>, label: Option<&str>, project: Option<&str>, parent_id: Option<&str>) -> Result<models::BtGlobalTreeNodeListResponse, Error<GetDocumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_q = q;
    let p_filter = filter;
    let p_owner = owner;
    let p_owner_type = owner_type;
    let p_sort_column = sort_column;
    let p_sort_order = sort_order;
    let p_offset = offset;
    let p_limit = limit;
    let p_label = label;
    let p_project = project;
    let p_parent_id = parent_id;

    let uri_str = format!("{}/documents", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_owner {
        req_builder = req_builder.query(&[("owner", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_owner_type {
        req_builder = req_builder.query(&[("ownerType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_column {
        req_builder = req_builder.query(&[("sortColumn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sortOrder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_label {
        req_builder = req_builder.query(&[("label", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_project {
        req_builder = req_builder.query(&[("project", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_id {
        req_builder = req_builder.query(&[("parentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtGlobalTreeNodeListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtGlobalTreeNodeListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_elements_in_document(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, link_document_id: Option<&str>, element_type: Option<&str>, element_id: Option<&str>, with_thumbnails: Option<bool>) -> Result<Vec<models::BtDocumentElementInfo>, Error<GetElementsInDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_link_document_id = link_document_id;
    let p_element_type = element_type;
    let p_element_id = element_id;
    let p_with_thumbnails = with_thumbnails;

    let uri_str = format!("{}/documents/d/{did}/{wvm}/{wvmid}/elements", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_type {
        req_builder = req_builder.query(&[("elementType", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_id {
        req_builder = req_builder.query(&[("elementId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_with_thumbnails {
        req_builder = req_builder.query(&[("withThumbnails", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtDocumentElementInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtDocumentElementInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetElementsInDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_insertables(configuration: &configuration::Configuration, did: &str, wv: &str, wvid: &str, element_id: Option<&str>, configuration2: Option<&str>, link_document_id: Option<&str>, include_parts: Option<bool>, include_surfaces: Option<bool>, include_sketches: Option<bool>, include_reference_features: Option<bool>, include_assemblies: Option<bool>, include_feature_studios: Option<bool>, include_blobs: Option<bool>, allowed_blob_mime_types: Option<&str>, exclude_newer_fs_versions: Option<bool>, max_feature_script_version: Option<i32>, include_part_studios: Option<bool>, include_features: Option<bool>, include_meshes: Option<bool>, include_wires: Option<bool>, include_flattened_bodies: Option<bool>, include_applications: Option<bool>, allowed_application_mime_types: Option<&str>, include_composite_parts: Option<bool>, include_fs_tables: Option<bool>, include_fs_computed_part_property_functions: Option<bool>, include_variables: Option<bool>, include_variable_studios: Option<bool>, allowed_blob_extensions: Option<&str>, is_obsoletion: Option<bool>) -> Result<models::BtInsertablesListResponse, Error<GetInsertablesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wv = wv;
    let p_wvid = wvid;
    let p_element_id = element_id;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;
    let p_include_parts = include_parts;
    let p_include_surfaces = include_surfaces;
    let p_include_sketches = include_sketches;
    let p_include_reference_features = include_reference_features;
    let p_include_assemblies = include_assemblies;
    let p_include_feature_studios = include_feature_studios;
    let p_include_blobs = include_blobs;
    let p_allowed_blob_mime_types = allowed_blob_mime_types;
    let p_exclude_newer_fs_versions = exclude_newer_fs_versions;
    let p_max_feature_script_version = max_feature_script_version;
    let p_include_part_studios = include_part_studios;
    let p_include_features = include_features;
    let p_include_meshes = include_meshes;
    let p_include_wires = include_wires;
    let p_include_flattened_bodies = include_flattened_bodies;
    let p_include_applications = include_applications;
    let p_allowed_application_mime_types = allowed_application_mime_types;
    let p_include_composite_parts = include_composite_parts;
    let p_include_fs_tables = include_fs_tables;
    let p_include_fs_computed_part_property_functions = include_fs_computed_part_property_functions;
    let p_include_variables = include_variables;
    let p_include_variable_studios = include_variable_studios;
    let p_allowed_blob_extensions = allowed_blob_extensions;
    let p_is_obsoletion = is_obsoletion;

    let uri_str = format!("{}/documents/d/{did}/{wv}/{wvid}/insertables", configuration.base_path, did=crate::apis::urlencode(p_did), wv=crate::apis::urlencode(p_wv), wvid=crate::apis::urlencode(p_wvid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_element_id {
        req_builder = req_builder.query(&[("elementId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_parts {
        req_builder = req_builder.query(&[("includeParts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_surfaces {
        req_builder = req_builder.query(&[("includeSurfaces", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_sketches {
        req_builder = req_builder.query(&[("includeSketches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_reference_features {
        req_builder = req_builder.query(&[("includeReferenceFeatures", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_assemblies {
        req_builder = req_builder.query(&[("includeAssemblies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_feature_studios {
        req_builder = req_builder.query(&[("includeFeatureStudios", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_blobs {
        req_builder = req_builder.query(&[("includeBlobs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_allowed_blob_mime_types {
        req_builder = req_builder.query(&[("allowedBlobMimeTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_newer_fs_versions {
        req_builder = req_builder.query(&[("excludeNewerFSVersions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_feature_script_version {
        req_builder = req_builder.query(&[("maxFeatureScriptVersion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_part_studios {
        req_builder = req_builder.query(&[("includePartStudios", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_features {
        req_builder = req_builder.query(&[("includeFeatures", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_meshes {
        req_builder = req_builder.query(&[("includeMeshes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_wires {
        req_builder = req_builder.query(&[("includeWires", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_flattened_bodies {
        req_builder = req_builder.query(&[("includeFlattenedBodies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_applications {
        req_builder = req_builder.query(&[("includeApplications", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_allowed_application_mime_types {
        req_builder = req_builder.query(&[("allowedApplicationMimeTypes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_composite_parts {
        req_builder = req_builder.query(&[("includeCompositeParts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_fs_tables {
        req_builder = req_builder.query(&[("includeFSTables", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_fs_computed_part_property_functions {
        req_builder = req_builder.query(&[("includeFSComputedPartPropertyFunctions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_variables {
        req_builder = req_builder.query(&[("includeVariables", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_variable_studios {
        req_builder = req_builder.query(&[("includeVariableStudios", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_allowed_blob_extensions {
        req_builder = req_builder.query(&[("allowedBlobExtensions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_obsoletion {
        req_builder = req_builder.query(&[("isObsoletion", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtInsertablesListResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtInsertablesListResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetInsertablesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_unit_info(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, link_document_id: Option<&str>) -> Result<models::BtUnitInfo, Error<GetUnitInfoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/documents/d/{did}/{wvm}/{wvmid}/unitinfo", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtUnitInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtUnitInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUnitInfoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_version(configuration: &configuration::Configuration, did: &str, vid: &str, parents: Option<bool>, link_document_id: Option<&str>) -> Result<models::BtVersionInfo, Error<GetVersionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_vid = vid;
    let p_parents = parents;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/documents/d/{did}/versions/{vid}", configuration.base_path, did=crate::apis::urlencode(p_did), vid=crate::apis::urlencode(p_vid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_parents {
        req_builder = req_builder.query(&[("parents", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtVersionInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtVersionInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetVersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn merge_into_workspace(configuration: &configuration::Configuration, did: &str, wid: &str, bt_version_or_workspace_merge_info: models::BtVersionOrWorkspaceMergeInfo) -> Result<models::BtDocumentMergeInfo, Error<MergeIntoWorkspaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_version_or_workspace_merge_info = bt_version_or_workspace_merge_info;

    let uri_str = format!("{}/documents/{did}/workspaces/{wid}/merge", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_version_or_workspace_merge_info);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtDocumentMergeInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtDocumentMergeInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MergeIntoWorkspaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn merge_preview(configuration: &configuration::Configuration, did: &str, wid: &str, source_type: &str, source_id: &str, link_document_id: Option<&str>) -> Result<models::BtMergePreviewInfo, Error<MergePreviewError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_source_type = source_type;
    let p_source_id = source_id;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/documents/{did}/w/{wid}/mergePreview", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("sourceType", &p_source_type.to_string())]);
    req_builder = req_builder.query(&[("sourceId", &p_source_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtMergePreviewInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtMergePreviewInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MergePreviewError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn move_elements_to_document(configuration: &configuration::Configuration, did: &str, wid: &str, bt_move_element_params: models::BtMoveElementParams) -> Result<models::BtMoveElementInfo, Error<MoveElementsToDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_move_element_params = bt_move_element_params;

    let uri_str = format!("{}/documents/d/{did}/w/{wid}/moveelement", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_move_element_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtMoveElementInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtMoveElementInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MoveElementsToDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn restore_from_history(configuration: &configuration::Configuration, did: &str, wid: &str, vm: &str, vmid: &str, link_document_id: Option<&str>, bt_restore_info: Option<models::BtRestoreInfo>) -> Result<models::BtRestoreFromHistoryInfo, Error<RestoreFromHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_vm = vm;
    let p_vmid = vmid;
    let p_link_document_id = link_document_id;
    let p_bt_restore_info = bt_restore_info;

    let uri_str = format!("{}/documents/{did}/w/{wid}/restore/{vm}/{vmid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), vm=crate::apis::urlencode(p_vm), vmid=crate::apis::urlencode(p_vmid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_restore_info);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtRestoreFromHistoryInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtRestoreFromHistoryInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RestoreFromHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn revert_unchanged_to_revisions(configuration: &configuration::Configuration, did: &str, wid: &str, bt_revert_unchanged_params: Option<models::BtRevertUnchangedParams>) -> Result<Vec<models::BtUnchangedElementInfo>, Error<RevertUnchangedToRevisionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_revert_unchanged_params = bt_revert_unchanged_params;

    let uri_str = format!("{}/documents/d/{did}/w/{wid}/revertunchangedtorevisions", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_revert_unchanged_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BtUnchangedElementInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BtUnchangedElementInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RevertUnchangedToRevisionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This returns list of documents based on search parameters.
pub async fn search(configuration: &configuration::Configuration, bt_document_search_params: models::BtDocumentSearchParams) -> Result<serde_json::Value, Error<SearchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_bt_document_search_params = bt_document_search_params;

    let uri_str = format!("{}/documents/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_document_search_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn share_document(configuration: &configuration::Configuration, did: &str, bt_share_params: models::BtShareParams) -> Result<models::BtAclInfo, Error<ShareDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_bt_share_params = bt_share_params;

    let uri_str = format!("{}/documents/{did}/share", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_share_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAclInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAclInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ShareDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn share_with_support(configuration: &configuration::Configuration, did: &str) -> Result<serde_json::Value, Error<ShareWithSupportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;

    let uri_str = format!("{}/documents/{did}/shareWithSupport", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ShareWithSupportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn sync_app_elements(configuration: &configuration::Configuration, did: &str, wid: &str, bt_sync_app_element_params: models::BtSyncAppElementParams) -> Result<serde_json::Value, Error<SyncAppElementsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_sync_app_element_params = bt_sync_app_element_params;

    let uri_str = format!("{}/documents/d/{did}/w/{wid}/syncAppElements", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_sync_app_element_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SyncAppElementsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Specify the ID of the entity to unshare with in the `eid` field, and specify the type of entity being identified in the `entryType` field. For example, to unshare a document with a company, you would use `1` as the `entryType` value and the `companyId` as the `entityId`.
pub async fn un_share_document(configuration: &configuration::Configuration, did: &str, eid: &str, entry_type: Option<i32>) -> Result<serde_json::Value, Error<UnShareDocumentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_entry_type = entry_type;

    let uri_str = format!("{}/documents/{did}/share/{eid}", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_entry_type {
        req_builder = req_builder.query(&[("entryType", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnShareDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn unshare_from_support(configuration: &configuration::Configuration, did: &str) -> Result<serde_json::Value, Error<UnshareFromSupportError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;

    let uri_str = format!("{}/documents/{did}/shareWithSupport", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnshareFromSupportError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// If anonymous access is allowed, you can allow or deny anonymous users the ability to export the document or publication. If `anonymousAccessAllowed=false` and `anonymousAllowsExport=true`, the call will throw an error.
pub async fn update_anonymous_access(configuration: &configuration::Configuration, did: &str, bt_acl_params: models::BtAclParams) -> Result<serde_json::Value, Error<UpdateAnonymousAccessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_bt_acl_params = bt_acl_params;

    let uri_str = format!("{}/documents/{did}/acl/anonymousAccess", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_acl_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAnonymousAccessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_document_attributes(configuration: &configuration::Configuration, did: &str, bt_document_params: models::BtDocumentParams) -> Result<models::BtDocumentSummaryInfo, Error<UpdateDocumentAttributesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_bt_document_params = bt_document_params;

    let uri_str = format!("{}/documents/{did}", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_document_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtDocumentSummaryInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtDocumentSummaryInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDocumentAttributesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_external_references_to_latest_documents(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, bt_link_to_latest_document_params: Option<models::BtLinkToLatestDocumentParams>) -> Result<models::BtLinkToLatestDocumentInfo, Error<UpdateExternalReferencesToLatestDocumentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_bt_link_to_latest_document_params = bt_link_to_latest_document_params;

    let uri_str = format!("{}/documents/d/{did}/w/{wid}/e/{eid}/latestdocumentreferences", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_link_to_latest_document_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtLinkToLatestDocumentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtLinkToLatestDocumentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateExternalReferencesToLatestDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  * Set `public=true` in the request body to make the document public. Set to `false` to make it private. Free users cannot make documents private.   * The `documentId` provided in the URL must match the one provided in the request body exactly. 
pub async fn update_public_access(configuration: &configuration::Configuration, did: &str, bt_acl_params: Option<models::BtAclParams>) -> Result<serde_json::Value, Error<UpdatePublicAccessError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_bt_acl_params = bt_acl_params;

    let uri_str = format!("{}/documents/{did}/acl/public", configuration.base_path, did=crate::apis::urlencode(p_did));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_acl_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePublicAccessError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

