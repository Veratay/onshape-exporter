/*
 * Onshape REST API
 *
 * ## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.
 *
 * The version of the OpenAPI document: 1.198.56658-8969b956ea73
 * Contact: api-support@onshape.zendesk.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_part_studio_feature`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddPartStudioFeatureError {
    DefaultResponse(models::BtFeatureDefinitionResponse1617),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`compare_part_studios`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ComparePartStudiosError {
    DefaultResponse(models::BtRootDiffInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_part_studio`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePartStudioError {
    DefaultResponse(models::BtDocumentElementInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_part_studio_export_step`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePartStudioExportStepError {
    DefaultResponse(models::BtTranslationRequestInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_part_studio_translation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePartStudioTranslationError {
    DefaultResponse(models::BtTranslationRequestInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_part_studio_feature`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePartStudioFeatureError {
    DefaultResponse(models::BtFeatureApiBase1430),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`eval_feature_script`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EvalFeatureScriptError {
    DefaultResponse(models::BtFeatureScriptEvalResponse1859),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_parasolid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportParasolidError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_part_studio_gltf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportPartStudioGltfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_part_studio_stl`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportPartStudioStlError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_feature_script_representation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFeatureScriptRepresentationError {
    DefaultResponse(models::BtpModule234),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_feature_script_table`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFeatureScriptTableError {
    DefaultResponse(models::BtApiTableList1223),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_body_details`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioBodyDetailsError {
    DefaultResponse(models::BtExportModelBodiesResponse734),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_bounding_boxes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioBoundingBoxesError {
    DefaultResponse(models::BtBoundingBoxInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_edges`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioEdgesError {
    DefaultResponse(models::BtExportTessellatedEdgesResponse327),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_faces`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioFacesError {
    DefaultResponse(models::BtExportTessellatedFacesResponse898),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_feature_specs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioFeatureSpecsError {
    DefaultResponse(models::BtFeatureSpecsResponse664),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_features`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioFeaturesError {
    DefaultResponse(models::BtFeatureListResponse2457),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_mass_properties`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioMassPropertiesError {
    DefaultResponse(models::BtMassPropertiesBulkInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_named_views`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioNamedViewsError {
    DefaultResponse(models::BtNamedViewsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_part_studio_shaded_views`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPartStudioShadedViewsError {
    DefaultResponse(models::BtShadedViewsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`translate_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TranslateIdsError {
    DefaultResponse(models::BtidTranslationInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_features`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFeaturesError {
    DefaultResponse(models::BtUpdateFeaturesResponse1333),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_part_studio_feature`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdatePartStudioFeatureError {
    DefaultResponse(models::BtFeatureDefinitionResponse1617),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_rollback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRollbackError {
    DefaultResponse(models::BtSetFeatureRollbackResponse1042),
    UnknownValue(serde_json::Value),
}


/// The feature is added immediately before the rollback bar. Any geometry IDs specified in the feature must be valid at that point in the feature tree.    See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
pub async fn add_part_studio_feature(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, bt_feature_definition_call1406: Option<models::BtFeatureDefinitionCall1406>) -> Result<models::BtFeatureDefinitionResponse1617, Error<AddPartStudioFeatureError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_bt_feature_definition_call1406 = bt_feature_definition_call1406;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_feature_definition_call1406);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureDefinitionResponse1617`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureDefinitionResponse1617`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddPartStudioFeatureError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn compare_part_studios(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, workspace_id: Option<&str>, version_id: Option<&str>, microversion_id: Option<&str>, source_configuration: Option<&str>, target_configuration: Option<&str>, link_document_id: Option<&str>) -> Result<models::BtRootDiffInfo, Error<ComparePartStudiosError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_workspace_id = workspace_id;
    let p_version_id = version_id;
    let p_microversion_id = microversion_id;
    let p_source_configuration = source_configuration;
    let p_target_configuration = target_configuration;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/compare", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_workspace_id {
        req_builder = req_builder.query(&[("workspaceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_version_id {
        req_builder = req_builder.query(&[("versionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_microversion_id {
        req_builder = req_builder.query(&[("microversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_source_configuration {
        req_builder = req_builder.query(&[("sourceConfiguration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_target_configuration {
        req_builder = req_builder.query(&[("targetConfiguration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtRootDiffInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtRootDiffInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ComparePartStudiosError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
pub async fn create_part_studio(configuration: &configuration::Configuration, did: &str, wid: &str, bt_model_element_params: models::BtModelElementParams) -> Result<models::BtDocumentElementInfo, Error<CreatePartStudioError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_model_element_params = bt_model_element_params;

    let uri_str = format!("{}/partstudios/d/{did}/w/{wid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_model_element_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtDocumentElementInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtDocumentElementInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePartStudioError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an asynchronous export of a Part Studio to STEP.  * See [API Guide: Asynchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#asynchronous-exports) for more details.
pub async fn create_part_studio_export_step(configuration: &configuration::Configuration, did: &str, wv: &str, wvid: &str, eid: &str, btb_step_export_params: models::BtbStepExportParams) -> Result<models::BtTranslationRequestInfo, Error<CreatePartStudioExportStepError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wv = wv;
    let p_wvid = wvid;
    let p_eid = eid;
    let p_btb_step_export_params = btb_step_export_params;

    let uri_str = format!("{}/partstudios/d/{did}/{wv}/{wvid}/e/{eid}/export/step", configuration.base_path, did=crate::apis::urlencode(p_did), wv=crate::apis::urlencode(p_wv), wvid=crate::apis::urlencode(p_wvid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_btb_step_export_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtTranslationRequestInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtTranslationRequestInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePartStudioExportStepError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an asynchronous export of a Part Studio to another file format.  * Can take longer than synchronous export options, but supports more formats and provides more control on tessellation and other settings.  * Use `formatName` in the JSON request body to specify the export file type. Use [Translations/getAllTranslatorFormats](#/Translation/getAllTranslatorFormats) to get a list of valid export file formats. ` * Set `storeInDocument` to `false` to export to a data file. Set to `true` to export to a blob element in the same document.  * See [API Guide: Asynchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#asynchronous-exports) for more details.
pub async fn create_part_studio_translation(configuration: &configuration::Configuration, did: &str, wv: &str, wvid: &str, eid: &str, bt_translate_format_params: models::BtTranslateFormatParams) -> Result<models::BtTranslationRequestInfo, Error<CreatePartStudioTranslationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wv = wv;
    let p_wvid = wvid;
    let p_eid = eid;
    let p_bt_translate_format_params = bt_translate_format_params;

    let uri_str = format!("{}/partstudios/d/{did}/{wv}/{wvid}/e/{eid}/translations", configuration.base_path, did=crate::apis::urlencode(p_did), wv=crate::apis::urlencode(p_wv), wvid=crate::apis::urlencode(p_wvid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_translate_format_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtTranslationRequestInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtTranslationRequestInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreatePartStudioTranslationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
pub async fn delete_part_studio_feature(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, fid: &str) -> Result<models::BtFeatureApiBase1430, Error<DeletePartStudioFeatureError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_fid = fid;

    let uri_str = format!("{}/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid), fid=crate::apis::urlencode(p_fid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureApiBase1430`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureApiBase1430`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeletePartStudioFeatureError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn eval_feature_script(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, bt_feature_script_eval_call2377: Option<models::BtFeatureScriptEvalCall2377>) -> Result<models::BtFeatureScriptEvalResponse1859, Error<EvalFeatureScriptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_bt_feature_script_eval_call2377 = bt_feature_script_eval_call2377;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurescript", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_feature_script_eval_call2377);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureScriptEvalResponse1859`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureScriptEvalResponse1859`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EvalFeatureScriptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a synchronous export of the Part Studio (with limited tessellation settings) to a Parasolid file.  * Returns a 307 redirect from which to download the exported file.  * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.  * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.    See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
pub async fn export_parasolid(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, part_ids: Option<&str>, version: Option<&str>, include_export_ids: Option<bool>, configuration2: Option<&str>, link_document_id: Option<&str>, binary_export: Option<bool>) -> Result<(), Error<ExportParasolidError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_part_ids = part_ids;
    let p_version = version;
    let p_include_export_ids = include_export_ids;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;
    let p_binary_export = binary_export;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/parasolid", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_part_ids {
        req_builder = req_builder.query(&[("partIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_export_ids {
        req_builder = req_builder.query(&[("includeExportIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_binary_export {
        req_builder = req_builder.query(&[("binaryExport", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportParasolidError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a synchronous export of the Part Studio (with limited tessellation settings) to a glTF file.  * Returns a 307 redirect from which to download the exported file.  * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.  * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.    See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
pub async fn export_part_studio_gltf(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, part_id: Option<Vec<String>>, angle_tolerance: Option<f64>, chord_tolerance: Option<f64>, precomputed_level_of_detail: Option<&str>, output_separate_face_nodes: Option<bool>, face_id: Option<Vec<String>>, output_face_appearances: Option<bool>, max_facet_width: Option<f64>) -> Result<models::GlTf, Error<ExportPartStudioGltfError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_part_id = part_id;
    let p_angle_tolerance = angle_tolerance;
    let p_chord_tolerance = chord_tolerance;
    let p_precomputed_level_of_detail = precomputed_level_of_detail;
    let p_output_separate_face_nodes = output_separate_face_nodes;
    let p_face_id = face_id;
    let p_output_face_appearances = output_face_appearances;
    let p_max_facet_width = max_facet_width;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/gltf", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_part_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("partId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("partId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_angle_tolerance {
        req_builder = req_builder.query(&[("angleTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chord_tolerance {
        req_builder = req_builder.query(&[("chordTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_precomputed_level_of_detail {
        req_builder = req_builder.query(&[("precomputedLevelOfDetail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_separate_face_nodes {
        req_builder = req_builder.query(&[("outputSeparateFaceNodes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_face_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("faceId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("faceId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_output_face_appearances {
        req_builder = req_builder.query(&[("outputFaceAppearances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_facet_width {
        req_builder = req_builder.query(&[("maxFacetWidth", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GlTf`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GlTf`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportPartStudioGltfError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a synchronous export of the Part Studio (with limited tessellation settings) to an STL file.  * Returns a 307 redirect from which to download the exported file.  * Export is much faster than asynchronous endpoints at the expense of limited control on tessellation settings.  * Use the [PartStudio/createPartStudioTranslation](#/PartStudio/createPartStudioTranslation) asynchronous export for greater control.    See [API Guide: Synchronous Exports](https://onshape-public.github.io/docs/api-adv/translation/#synchronous-exports) for more details.
pub async fn export_part_studio_stl(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, part_ids: Option<&str>, mode: Option<&str>, grouping: Option<bool>, scale: Option<f64>, units: Option<&str>, angle_tolerance: Option<f64>, chord_tolerance: Option<f64>, max_facet_width: Option<f64>, min_facet_width: Option<f64>, configuration2: Option<&str>, link_document_id: Option<&str>) -> Result<(), Error<ExportPartStudioStlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_part_ids = part_ids;
    let p_mode = mode;
    let p_grouping = grouping;
    let p_scale = scale;
    let p_units = units;
    let p_angle_tolerance = angle_tolerance;
    let p_chord_tolerance = chord_tolerance;
    let p_max_facet_width = max_facet_width;
    let p_min_facet_width = min_facet_width;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/stl", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_part_ids {
        req_builder = req_builder.query(&[("partIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_grouping {
        req_builder = req_builder.query(&[("grouping", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scale {
        req_builder = req_builder.query(&[("scale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_units {
        req_builder = req_builder.query(&[("units", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_angle_tolerance {
        req_builder = req_builder.query(&[("angleTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chord_tolerance {
        req_builder = req_builder.query(&[("chordTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_facet_width {
        req_builder = req_builder.query(&[("maxFacetWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_min_facet_width {
        req_builder = req_builder.query(&[("minFacetWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportPartStudioStlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_feature_script_representation(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>) -> Result<models::BtpModule234, Error<GetFeatureScriptRepresentationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurescriptrepresentation", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtpModule234`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtpModule234`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFeatureScriptRepresentationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_feature_script_table(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, table_type: &str, configuration2: Option<&str>, table_namespace: Option<&str>, table_parameters: Option<&str>, part_id: Option<&str>, link_document_id: Option<&str>) -> Result<models::BtApiTableList1223, Error<GetFeatureScriptTableError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_table_type = table_type;
    let p_configuration = configuration2;
    let p_table_namespace = table_namespace;
    let p_table_parameters = table_parameters;
    let p_part_id = part_id;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/fstable", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_table_namespace {
        req_builder = req_builder.query(&[("tableNamespace", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("tableType", &p_table_type.to_string())]);
    if let Some(ref param_value) = p_table_parameters {
        req_builder = req_builder.query(&[("tableParameters", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_part_id {
        req_builder = req_builder.query(&[("partId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtApiTableList1223`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtApiTableList1223`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFeatureScriptTableError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
pub async fn get_part_studio_body_details(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, part_ids: Option<Vec<String>>, include_surfaces: Option<bool>, include_composite_parts: Option<bool>, include_geometric_data: Option<bool>) -> Result<models::BtExportModelBodiesResponse734, Error<GetPartStudioBodyDetailsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_part_ids = part_ids;
    let p_include_surfaces = include_surfaces;
    let p_include_composite_parts = include_composite_parts;
    let p_include_geometric_data = include_geometric_data;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/bodydetails", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_part_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("partIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("partIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_include_surfaces {
        req_builder = req_builder.query(&[("includeSurfaces", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_composite_parts {
        req_builder = req_builder.query(&[("includeCompositeParts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_geometric_data {
        req_builder = req_builder.query(&[("includeGeometricData", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtExportModelBodiesResponse734`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtExportModelBodiesResponse734`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioBodyDetailsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This endpoint does not result in a tight bounding box. The values returned are meant for graphics and visualization, and are approximate.  To calculate a tight bounding box, see the [FeatureScript API Guide](https://onshape-public.github.io/docs/api-adv/fs/#calculate-a-tight-bounding-box). 
pub async fn get_part_studio_bounding_boxes(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, include_hidden: Option<bool>, include_wire_bodies: Option<bool>, configuration2: Option<&str>, link_document_id: Option<&str>) -> Result<models::BtBoundingBoxInfo, Error<GetPartStudioBoundingBoxesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_include_hidden = include_hidden;
    let p_include_wire_bodies = include_wire_bodies;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/boundingboxes", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_hidden {
        req_builder = req_builder.query(&[("includeHidden", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_wire_bodies {
        req_builder = req_builder.query(&[("includeWireBodies", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtBoundingBoxInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtBoundingBoxInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioBoundingBoxesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the edges as tessellated data and includes display data.  Coordinates are in meters (m).
pub async fn get_part_studio_edges(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, part_id: Option<Vec<String>>, angle_tolerance: Option<f64>, chord_tolerance: Option<f64>, precomputed_level_of_detail: Option<&str>, edge_id: Option<Vec<String>>) -> Result<models::BtExportTessellatedEdgesResponse327, Error<GetPartStudioEdgesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_part_id = part_id;
    let p_angle_tolerance = angle_tolerance;
    let p_chord_tolerance = chord_tolerance;
    let p_precomputed_level_of_detail = precomputed_level_of_detail;
    let p_edge_id = edge_id;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/tessellatededges", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_part_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("partId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("partId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_angle_tolerance {
        req_builder = req_builder.query(&[("angleTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chord_tolerance {
        req_builder = req_builder.query(&[("chordTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_precomputed_level_of_detail {
        req_builder = req_builder.query(&[("precomputedLevelOfDetail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_edge_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("edgeId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("edgeId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtExportTessellatedEdgesResponse327`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtExportTessellatedEdgesResponse327`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioEdgesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Coordinates are in meters (m).
pub async fn get_part_studio_faces(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, part_id: Option<Vec<String>>, angle_tolerance: Option<f64>, chord_tolerance: Option<f64>, precomputed_level_of_detail: Option<&str>, face_id: Option<Vec<String>>, output_face_appearances: Option<bool>, max_facet_width: Option<f64>, output_vertex_normals: Option<bool>, output_facet_normals: Option<bool>, output_texture_coordinates: Option<bool>, output_index_table: Option<bool>, output_error_faces: Option<bool>, combine_composite_part_constituents: Option<bool>) -> Result<models::BtExportTessellatedFacesResponse898, Error<GetPartStudioFacesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_part_id = part_id;
    let p_angle_tolerance = angle_tolerance;
    let p_chord_tolerance = chord_tolerance;
    let p_precomputed_level_of_detail = precomputed_level_of_detail;
    let p_face_id = face_id;
    let p_output_face_appearances = output_face_appearances;
    let p_max_facet_width = max_facet_width;
    let p_output_vertex_normals = output_vertex_normals;
    let p_output_facet_normals = output_facet_normals;
    let p_output_texture_coordinates = output_texture_coordinates;
    let p_output_index_table = output_index_table;
    let p_output_error_faces = output_error_faces;
    let p_combine_composite_part_constituents = combine_composite_part_constituents;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/tessellatedfaces", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_part_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("partId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("partId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_angle_tolerance {
        req_builder = req_builder.query(&[("angleTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_chord_tolerance {
        req_builder = req_builder.query(&[("chordTolerance", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_precomputed_level_of_detail {
        req_builder = req_builder.query(&[("precomputedLevelOfDetail", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_face_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("faceId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("faceId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_output_face_appearances {
        req_builder = req_builder.query(&[("outputFaceAppearances", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_facet_width {
        req_builder = req_builder.query(&[("maxFacetWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_vertex_normals {
        req_builder = req_builder.query(&[("outputVertexNormals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_facet_normals {
        req_builder = req_builder.query(&[("outputFacetNormals", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_texture_coordinates {
        req_builder = req_builder.query(&[("outputTextureCoordinates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_index_table {
        req_builder = req_builder.query(&[("outputIndexTable", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_error_faces {
        req_builder = req_builder.query(&[("outputErrorFaces", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_combine_composite_part_constituents {
        req_builder = req_builder.query(&[("combineCompositePartConstituents", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtExportTessellatedFacesResponse898`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtExportTessellatedFacesResponse898`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioFacesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of feature specs available within the Part Studio. A feature spec provides a data description of the feature's interface to a feature.
pub async fn get_part_studio_feature_specs(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str) -> Result<models::BtFeatureSpecsResponse664, Error<GetPartStudioFeatureSpecsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/featurespecs", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureSpecsResponse664`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureSpecsResponse664`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioFeatureSpecsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
pub async fn get_part_studio_features(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, include_geometry_ids: Option<bool>, feature_id: Option<Vec<String>>, no_sketch_geometry: Option<bool>) -> Result<models::BtFeatureListResponse2457, Error<GetPartStudioFeaturesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_include_geometry_ids = include_geometry_ids;
    let p_feature_id = feature_id;
    let p_no_sketch_geometry = no_sketch_geometry;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/features", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_geometry_ids {
        req_builder = req_builder.query(&[("includeGeometryIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_feature_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("featureId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("featureId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_no_sketch_geometry {
        req_builder = req_builder.query(&[("noSketchGeometry", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureListResponse2457`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureListResponse2457`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioFeaturesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Parts must have density. The returned schema includes the same information as in the Onshape [Mass Properties Tool](https://cad.onshape.com/help/Content/massprops-ps.htm).    When three values are returned:   * The first is the calculated value.   * The second is the minimum possible value, considering tolerance.   * The third is the maximum possible value, considering tolerance.     See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
pub async fn get_part_studio_mass_properties(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, configuration2: Option<&str>, rollback_bar_index: Option<i32>, element_microversion_id: Option<&str>, part_id: Option<Vec<String>>, mass_as_group: Option<bool>, use_mass_property_overrides: Option<bool>) -> Result<models::BtMassPropertiesBulkInfo, Error<GetPartStudioMassPropertiesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_configuration = configuration2;
    let p_rollback_bar_index = rollback_bar_index;
    let p_element_microversion_id = element_microversion_id;
    let p_part_id = part_id;
    let p_mass_as_group = mass_as_group;
    let p_use_mass_property_overrides = use_mass_property_overrides;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/massproperties", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_rollback_bar_index {
        req_builder = req_builder.query(&[("rollbackBarIndex", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_microversion_id {
        req_builder = req_builder.query(&[("elementMicroversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_part_id {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("partId".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("partId", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_mass_as_group {
        req_builder = req_builder.query(&[("massAsGroup", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_mass_property_overrides {
        req_builder = req_builder.query(&[("useMassPropertyOverrides", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtMassPropertiesBulkInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtMassPropertiesBulkInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioMassPropertiesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a map from view name to view data for the given element. See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
pub async fn get_part_studio_named_views(configuration: &configuration::Configuration, did: &str, eid: &str, link_document_id: Option<&str>, skip_perspective: Option<bool>, include_section_cut_views: Option<bool>) -> Result<models::BtNamedViewsInfo, Error<GetPartStudioNamedViewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_skip_perspective = skip_perspective;
    let p_include_section_cut_views = include_section_cut_views;

    let uri_str = format!("{}/partstudios/d/{did}/e/{eid}/namedViews", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_perspective {
        req_builder = req_builder.query(&[("skipPerspective", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_section_cut_views {
        req_builder = req_builder.query(&[("includeSectionCutViews", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtNamedViewsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtNamedViewsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioNamedViewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_part_studio_shaded_views(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, view_matrix: Option<&str>, output_height: Option<i32>, output_width: Option<i32>, pixel_size: Option<f64>, edges: Option<&str>, show_all_parts: Option<bool>, include_surfaces: Option<bool>, use_anti_aliasing: Option<bool>, include_wires: Option<bool>, configuration2: Option<&str>, link_document_id: Option<&str>) -> Result<models::BtShadedViewsInfo, Error<GetPartStudioShadedViewsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_view_matrix = view_matrix;
    let p_output_height = output_height;
    let p_output_width = output_width;
    let p_pixel_size = pixel_size;
    let p_edges = edges;
    let p_show_all_parts = show_all_parts;
    let p_include_surfaces = include_surfaces;
    let p_use_anti_aliasing = use_anti_aliasing;
    let p_include_wires = include_wires;
    let p_configuration = configuration2;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/shadedviews", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_view_matrix {
        req_builder = req_builder.query(&[("viewMatrix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_height {
        req_builder = req_builder.query(&[("outputHeight", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_output_width {
        req_builder = req_builder.query(&[("outputWidth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pixel_size {
        req_builder = req_builder.query(&[("pixelSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_edges {
        req_builder = req_builder.query(&[("edges", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_show_all_parts {
        req_builder = req_builder.query(&[("showAllParts", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_surfaces {
        req_builder = req_builder.query(&[("includeSurfaces", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_anti_aliasing {
        req_builder = req_builder.query(&[("useAntiAliasing", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_wires {
        req_builder = req_builder.query(&[("includeWires", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_configuration {
        req_builder = req_builder.query(&[("configuration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtShadedViewsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtShadedViewsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetPartStudioShadedViewsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// * Deterministic IDs are only valid for one microversion.  * This maps deterministic IDs between microversions in an attempt to find the corresponding entities in each version.
pub async fn translate_ids(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, btid_translation_params: models::BtidTranslationParams) -> Result<models::BtidTranslationInfo, Error<TranslateIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_btid_translation_params = btid_translation_params;

    let uri_str = format!("{}/partstudios/d/{did}/{wvm}/{wvmid}/e/{eid}/idtranslations", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_btid_translation_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtidTranslationInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtidTranslationInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TranslateIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This API accepts a list of features (that must already exist in the Part Studio) to update. This call does not fully redefine the features; it updates only the parameters supplied in the top-level feature structure, and optionally can update feature suppression attributes.  See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
pub async fn update_features(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, bt_update_features_call1748: Option<models::BtUpdateFeaturesCall1748>) -> Result<models::BtUpdateFeaturesResponse1333, Error<UpdateFeaturesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_bt_update_features_call1748 = bt_update_features_call1748;

    let uri_str = format!("{}/partstudios/d/{did}/w/{wid}/e/{eid}/features/updates", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_update_features_call1748);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtUpdateFeaturesResponse1333`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtUpdateFeaturesResponse1333`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateFeaturesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replaces an existing feature in the location of the existing feature. See the [Features API Guide](https://onshape-public.github.io/docs/api-adv/featureaccess/) for additional information.
pub async fn update_part_studio_feature(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, fid: &str, bt_feature_definition_call1406: Option<models::BtFeatureDefinitionCall1406>) -> Result<models::BtFeatureDefinitionResponse1617, Error<UpdatePartStudioFeatureError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_fid = fid;
    let p_bt_feature_definition_call1406 = bt_feature_definition_call1406;

    let uri_str = format!("{}/partstudios/d/{did}/w/{wid}/e/{eid}/features/featureid/{fid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid), fid=crate::apis::urlencode(p_fid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_feature_definition_call1406);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtFeatureDefinitionResponse1617`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtFeatureDefinitionResponse1617`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdatePartStudioFeatureError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Replace `\"string\"` in the request body with an object that specifies the new location for the rollback bar:   `{ \"rollbackIndex\": integer }`   For example: `{ \"rollbackIndex\": 2 }`   Set to `-1` to move the rollback bar to the end of the list.   See the [Part Studios API Guide](https://onshape-public.github.io/docs/api-adv/partstudios/) for details and tutorials.
pub async fn update_rollback(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, body: &str) -> Result<models::BtSetFeatureRollbackResponse1042, Error<UpdateRollbackError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_body = body;

    let uri_str = format!("{}/partstudios/d/{did}/w/{wid}/e/{eid}/features/rollback", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtSetFeatureRollbackResponse1042`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtSetFeatureRollbackResponse1042`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateRollbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

