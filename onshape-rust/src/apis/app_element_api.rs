/*
 * Onshape REST API
 *
 * ## Welcome to the Onshape REST API Explorer  To use this API explorer, sign in to your [Onshape](https://cad.onshape.com) account in another tab, then click the **Try it out** button below (it toggles to a **Cancel** button when selected).  See the **[API Explorer Guide](https://onshape-public.github.io/docs/api-intro/explorer/)** for help navigating this API Explorer, including **[authentication](https://onshape-public.github.io/docs/api-intro/explorer/#authentication)**.  **Tip:** To ensure the current session isn't used when trying other authentication techniques, make sure to [remove the Onshape cookie](https://support.google.com/chrome/answer/95647#zippy=%2Cdelete-cookies-from-a-site) as per the instructions for your browser. Alternatively, you can use a private or incognito window.  ## See Also  * [Onshape API Guide](https://onshape-public.github.io/docs/): Our full suite of developer guides, to be used as an accompaniment to this API Explorer. * [Onshape Developer Portal](https://cad.onshape.com/appstore/dev-portal): The Onshape portal for managing your API keys, OAuth2 credentials, your Onshape applications, and your Onshape App Store entries. * [Authentication Guide](https://onshape-public.github.io/docs/auth/): Our guide to using API keys, request signatures, and OAuth2 in  your Onshape applications.
 *
 * The version of the OpenAPI document: 1.198.56658-8969b956ea73
 * Contact: api-support@onshape.zendesk.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use serde_json;
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`abort_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbortTransactionError {
    DefaultResponse(serde_json::Value),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_create_element`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkCreateElementError {
    DefaultResponse(models::BtAppElementBulkCreateInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`commit_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CommitTransactionsError {
    DefaultResponse(models::BtAppElementBulkModifyInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`compare_app_element_json`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompareAppElementJsonError {
    DefaultResponse(models::BtDiffJsonResponse2725),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_element`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateElementError {
    DefaultResponse(models::BtAppElementModifyInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_reference`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateReferenceError {
    DefaultResponse(models::BtAppElementReferenceInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_app_element_content`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAppElementContentError {
    DefaultResponse(models::BtAppElementModifyInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_app_element_content_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAppElementContentBatchError {
    DefaultResponse(models::BtAppElementModifyInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_blob_subelement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteBlobSubelementError {
    DefaultResponse(models::BtAppElementModifyInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_reference`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteReferenceError {
    DefaultResponse(models::BtAppElementReferenceInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_blob_subelement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadBlobSubelementError {
    DefaultResponse(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_blob_subelement_workspace`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadBlobSubelementWorkspaceError {
    DefaultResponse(std::path::PathBuf),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_app_element_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppElementHistoryError {
    DefaultResponse(models::BtAppElementHistoryInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_blob_subelement_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetBlobSubelementIdsError {
    DefaultResponse(models::BtAppElementIdsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_element_transactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetElementTransactionsError {
    DefaultResponse(models::BtAppElementTransactionsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_json`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJsonError {
    DefaultResponse(models::BtGetJsonResponse2137),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_json_paths`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetJsonPathsError {
    DefaultResponse(models::BtGetJsonPathsResponse1544),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_element_content`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubElementContentError {
    DefaultResponse(models::BtAppElementContentInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sub_element_content_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubElementContentBatchError {
    DefaultResponse(models::BtAppElementContentInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_subelement_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSubelementIdsError {
    DefaultResponse(models::BtAppElementIdsInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resolve_all_element_references`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResolveAllElementReferencesError {
    DefaultResponse(std::collections::HashMap<String, models::BtAppElementReferencesResolveInfo>),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resolve_reference`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResolveReferenceError {
    DefaultResponse(models::BtAppElementReferenceResolveInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resolve_references`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResolveReferencesError {
    DefaultResponse(models::BtAppElementReferencesResolveInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_transaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartTransactionError {
    DefaultResponse(models::BtAppElementModifyInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_app_element`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAppElementError {
    DefaultResponse(models::BtAppElementModifyInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_reference`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateReferenceError {
    DefaultResponse(models::BtAppElementReferenceInfo),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_blob_subelement`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadBlobSubelementError {
    DefaultResponse(models::BtAppElementModifyInfo),
    UnknownValue(serde_json::Value),
}


/// Deletes a microbranch (i.e., the branch with the microversion for the transaction).
pub async fn abort_transaction(configuration: &configuration::Configuration, did: &str, eid: &str, wid: &str, tid: &str, return_error: Option<bool>) -> Result<serde_json::Value, Error<AbortTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wid = wid;
    let p_tid = tid;
    let p_return_error = return_error;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}/e/{eid}/transactions/{tid}", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wid=crate::apis::urlencode(p_wid), tid=crate::apis::urlencode(p_tid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_return_error {
        req_builder = req_builder.query(&[("returnError", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AbortTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Call this faster API instead of creating multiple app elements one at a time or in parallel.
pub async fn bulk_create_element(configuration: &configuration::Configuration, did: &str, wid: &str, bt_app_element_bulk_create_params: models::BtAppElementBulkCreateParams, link_document_id: Option<&str>) -> Result<models::BtAppElementBulkCreateInfo, Error<BulkCreateElementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_app_element_bulk_create_params = bt_app_element_bulk_create_params;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}/bulkcreate", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_app_element_bulk_create_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementBulkCreateInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementBulkCreateInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkCreateElementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// If successful, all transactions will be committed to a single microversion. If the call raises an error, nothing will be committed.
pub async fn commit_transactions(configuration: &configuration::Configuration, did: &str, wid: &str, bt_app_element_commit_transaction_params: models::BtAppElementCommitTransactionParams, link_document_id: Option<&str>) -> Result<models::BtAppElementBulkModifyInfo, Error<CommitTransactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_app_element_commit_transaction_params = bt_app_element_commit_transaction_params;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}/transactions", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_app_element_commit_transaction_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementBulkModifyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementBulkModifyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CommitTransactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Specify the source workspace/version/microversion in the URL and specify the target workspace/version/microversion in the query parameters.
pub async fn compare_app_element_json(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, workspace_id: Option<&str>, version_id: Option<&str>, microversion_id: Option<&str>, link_document_id: Option<&str>, json_difference_format: Option<&str>) -> Result<models::BtDiffJsonResponse2725, Error<CompareAppElementJsonError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_workspace_id = workspace_id;
    let p_version_id = version_id;
    let p_microversion_id = microversion_id;
    let p_link_document_id = link_document_id;
    let p_json_difference_format = json_difference_format;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/compare", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_workspace_id {
        req_builder = req_builder.query(&[("workspaceId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_version_id {
        req_builder = req_builder.query(&[("versionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_microversion_id {
        req_builder = req_builder.query(&[("microversionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_json_difference_format {
        req_builder = req_builder.query(&[("jsonDifferenceFormat", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtDiffJsonResponse2725`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtDiffJsonResponse2725`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompareAppElementJsonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_element(configuration: &configuration::Configuration, did: &str, wid: &str, bt_app_element_params: models::BtAppElementParams, link_document_id: Option<&str>) -> Result<models::BtAppElementModifyInfo, Error<CreateElementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_bt_app_element_params = bt_app_element_params;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_app_element_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementModifyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementModifyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateElementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_reference(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, bt_app_element_reference_params: models::BtAppElementReferenceParams) -> Result<models::BtAppElementReferenceInfo, Error<CreateReferenceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_bt_app_element_reference_params = bt_app_element_reference_params;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_app_element_reference_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementReferenceInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementReferenceInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateReferenceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_app_element_content(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, sid: &str, transaction_id: Option<&str>, parent_change_id: Option<&str>, description: Option<&str>) -> Result<models::BtAppElementModifyInfo, Error<DeleteAppElementContentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_sid = sid;
    let p_transaction_id = transaction_id;
    let p_parent_change_id = parent_change_id;
    let p_description = description;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements/{sid}", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), sid=crate::apis::urlencode(p_sid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_change_id {
        req_builder = req_builder.query(&[("parentChangeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementModifyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementModifyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAppElementContentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_app_element_content_batch(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, subelement_ids: Option<Vec<String>>, transaction_id: Option<&str>, parent_change_id: Option<&str>, description: Option<&str>) -> Result<models::BtAppElementModifyInfo, Error<DeleteAppElementContentBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_subelement_ids = subelement_ids;
    let p_transaction_id = transaction_id;
    let p_parent_change_id = parent_change_id;
    let p_description = description;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_subelement_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("subelementIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("subelementIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_change_id {
        req_builder = req_builder.query(&[("parentChangeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementModifyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementModifyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAppElementContentBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_blob_subelement(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, bid: &str, transaction_id: Option<&str>, change_id: Option<&str>) -> Result<models::BtAppElementModifyInfo, Error<DeleteBlobSubelementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_bid = bid;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid), bid=crate::apis::urlencode(p_bid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementModifyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementModifyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteBlobSubelementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_reference(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, rid: &str, transaction_id: Option<&str>, parent_change_id: Option<&str>, description: Option<&str>) -> Result<models::BtAppElementReferenceInfo, Error<DeleteReferenceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_rid = rid;
    let p_transaction_id = transaction_id;
    let p_parent_change_id = parent_change_id;
    let p_description = description;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), rid=crate::apis::urlencode(p_rid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_change_id {
        req_builder = req_builder.query(&[("parentChangeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementReferenceInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementReferenceInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteReferenceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Download a blob subelement as a file.
pub async fn download_blob_subelement(configuration: &configuration::Configuration, did: &str, vm: &str, vmid: &str, eid: &str, bid: &str, content_disposition: Option<&str>, if_none_match: Option<&str>, transaction_id: Option<&str>, change_id: Option<&str>, link_document_id: Option<&str>) -> Result<std::path::PathBuf, Error<DownloadBlobSubelementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_vm = vm;
    let p_vmid = vmid;
    let p_eid = eid;
    let p_bid = bid;
    let p_content_disposition = content_disposition;
    let p_if_none_match = if_none_match;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/appelements/d/{did}/{vm}/{vmid}/e/{eid}/blob/{bid}", configuration.base_path, did=crate::apis::urlencode(p_did), vm=crate::apis::urlencode(p_vm), vmid=crate::apis::urlencode(p_vmid), eid=crate::apis::urlencode(p_eid), bid=crate::apis::urlencode(p_bid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content_disposition {
        req_builder = req_builder.query(&[("contentDisposition", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::path::PathBuf`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::path::PathBuf`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadBlobSubelementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// The downloaded file can be used to retrieve stored subelements.
pub async fn download_blob_subelement_workspace(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, bid: &str, content_disposition: Option<&str>, if_none_match: Option<&str>, transaction_id: Option<&str>, change_id: Option<&str>) -> Result<std::path::PathBuf, Error<DownloadBlobSubelementWorkspaceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_bid = bid;
    let p_content_disposition = content_disposition;
    let p_if_none_match = if_none_match;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid), bid=crate::apis::urlencode(p_bid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_content_disposition {
        req_builder = req_builder.query(&[("contentDisposition", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::path::PathBuf`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::path::PathBuf`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DownloadBlobSubelementWorkspaceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_app_element_history(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str) -> Result<models::BtAppElementHistoryInfo, Error<GetAppElementHistoryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/history", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementHistoryInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementHistoryInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAppElementHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_blob_subelement_ids(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, transaction_id: Option<&str>, change_id: Option<&str>) -> Result<models::BtAppElementIdsInfo, Error<GetBlobSubelementIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/blob", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementIdsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementIdsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetBlobSubelementIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_element_transactions(configuration: &configuration::Configuration, did: &str, eid: &str, wid: &str) -> Result<models::BtAppElementTransactionsInfo, Error<GetElementTransactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wid = wid;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}/e/{eid}/transactions", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementTransactionsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementTransactionsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetElementTransactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_json(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, transaction_id: Option<&str>, change_id: Option<&str>) -> Result<models::BtGetJsonResponse2137, Error<GetJsonError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/json", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtGetJsonResponse2137`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtGetJsonResponse2137`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJsonError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use this endpoint to return the JSON at the specified path instead of returning the entire JSON for the element. This POST endpoint does not write any information.
pub async fn get_json_paths(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, transaction_id: Option<&str>, change_id: Option<&str>, bt_get_json_paths1697: Option<models::BtGetJsonPaths1697>) -> Result<models::BtGetJsonPathsResponse1544, Error<GetJsonPathsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;
    let p_bt_get_json_paths1697 = bt_get_json_paths1697;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/jsonpaths", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_get_json_paths1697);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtGetJsonPathsResponse1544`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtGetJsonPathsResponse1544`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetJsonPathsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_sub_element_content(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, transaction_id: Option<&str>, change_id: Option<&str>, base_change_id: Option<&str>, subelement_id: Option<&str>) -> Result<models::BtAppElementContentInfo, Error<GetSubElementContentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;
    let p_base_change_id = base_change_id;
    let p_subelement_id = subelement_id;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_base_change_id {
        req_builder = req_builder.query(&[("baseChangeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_subelement_id {
        req_builder = req_builder.query(&[("subelementId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementContentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementContentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubElementContentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_sub_element_content_batch(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, transaction_id: Option<&str>, change_id: Option<&str>, base_change_id: Option<&str>, subelement_ids: Option<Vec<String>>) -> Result<models::BtAppElementContentInfo, Error<GetSubElementContentBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;
    let p_base_change_id = base_change_id;
    let p_subelement_ids = subelement_ids;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/subelements", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_base_change_id {
        req_builder = req_builder.query(&[("baseChangeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_subelement_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("subelementIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("subelementIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementContentInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementContentInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubElementContentBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_subelement_ids(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, transaction_id: Option<&str>, change_id: Option<&str>) -> Result<models::BtAppElementIdsInfo, Error<GetSubelementIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_transaction_id = transaction_id;
    let p_change_id = change_id;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content/ids", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_change_id {
        req_builder = req_builder.query(&[("changeId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementIdsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementIdsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSubelementIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Resolve all references for all workspace elements. For bulk operations  only. Use `resolveReferences` for a single element.
pub async fn resolve_all_element_references(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, link_document_id: Option<&str>, transaction_id: Option<&str>, parent_change_id: Option<&str>, include_internal: Option<bool>, reference_ids: Option<&str>, element_ids: Option<&str>, drawings_only: Option<bool>) -> Result<std::collections::HashMap<String, models::BtAppElementReferencesResolveInfo>, Error<ResolveAllElementReferencesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_link_document_id = link_document_id;
    let p_transaction_id = transaction_id;
    let p_parent_change_id = parent_change_id;
    let p_include_internal = include_internal;
    let p_reference_ids = reference_ids;
    let p_element_ids = element_ids;
    let p_drawings_only = drawings_only;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/resolvereferences", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_change_id {
        req_builder = req_builder.query(&[("parentChangeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_internal {
        req_builder = req_builder.query(&[("includeInternal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_reference_ids {
        req_builder = req_builder.query(&[("referenceIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_element_ids {
        req_builder = req_builder.query(&[("elementIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_drawings_only {
        req_builder = req_builder.query(&[("drawingsOnly", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::BtAppElementReferencesResolveInfo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::BtAppElementReferencesResolveInfo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResolveAllElementReferencesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// For single operations only. Use `resolveReferences` for bulk operations.
pub async fn resolve_reference(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, rid: &str, transaction_id: Option<&str>, parent_change_id: Option<&str>, include_internal: Option<bool>, link_document_id: Option<&str>) -> Result<models::BtAppElementReferenceResolveInfo, Error<ResolveReferenceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_rid = rid;
    let p_transaction_id = transaction_id;
    let p_parent_change_id = parent_change_id;
    let p_include_internal = include_internal;
    let p_link_document_id = link_document_id;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), rid=crate::apis::urlencode(p_rid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_change_id {
        req_builder = req_builder.query(&[("parentChangeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_internal {
        req_builder = req_builder.query(&[("includeInternal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementReferenceResolveInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementReferenceResolveInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResolveReferenceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// For bulk operations only. Use `resolveReference` for a single operation.
pub async fn resolve_references(configuration: &configuration::Configuration, did: &str, wvm: &str, wvmid: &str, eid: &str, link_document_id: Option<&str>, transaction_id: Option<&str>, parent_change_id: Option<&str>, include_internal: Option<bool>, reference_ids: Option<&str>) -> Result<models::BtAppElementReferencesResolveInfo, Error<ResolveReferencesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_eid = eid;
    let p_link_document_id = link_document_id;
    let p_transaction_id = transaction_id;
    let p_parent_change_id = parent_change_id;
    let p_include_internal = include_internal;
    let p_reference_ids = reference_ids;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/resolvereferences", configuration.base_path, did=crate::apis::urlencode(p_did), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), eid=crate::apis::urlencode(p_eid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_link_document_id {
        req_builder = req_builder.query(&[("linkDocumentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_transaction_id {
        req_builder = req_builder.query(&[("transactionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_change_id {
        req_builder = req_builder.query(&[("parentChangeId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_internal {
        req_builder = req_builder.query(&[("includeInternal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_reference_ids {
        req_builder = req_builder.query(&[("referenceIds", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementReferencesResolveInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementReferencesResolveInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResolveReferencesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a microbranch (i.e., a branch for a new microversion).
pub async fn start_transaction(configuration: &configuration::Configuration, did: &str, eid: &str, wid: &str, bt_app_element_start_transaction_params: models::BtAppElementStartTransactionParams) -> Result<models::BtAppElementModifyInfo, Error<StartTransactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wid = wid;
    let p_bt_app_element_start_transaction_params = bt_app_element_start_transaction_params;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}/e/{eid}/transactions", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wid=crate::apis::urlencode(p_wid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_app_element_start_transaction_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementModifyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementModifyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartTransactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_app_element(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, bt_app_element_update_params: Option<models::BtAppElementUpdateParams>) -> Result<models::BtAppElementModifyInfo, Error<UpdateAppElementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_bt_app_element_update_params = bt_app_element_update_params;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/content", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_app_element_update_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementModifyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementModifyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAppElementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_reference(configuration: &configuration::Configuration, did: &str, eid: &str, wvm: &str, wvmid: &str, rid: &str, bt_app_element_reference_params: models::BtAppElementReferenceParams) -> Result<models::BtAppElementReferenceInfo, Error<UpdateReferenceError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_eid = eid;
    let p_wvm = wvm;
    let p_wvmid = wvmid;
    let p_rid = rid;
    let p_bt_app_element_reference_params = bt_app_element_reference_params;

    let uri_str = format!("{}/appelements/d/{did}/{wvm}/{wvmid}/e/{eid}/references/{rid}", configuration.base_path, did=crate::apis::urlencode(p_did), eid=crate::apis::urlencode(p_eid), wvm=crate::apis::urlencode(p_wvm), wvmid=crate::apis::urlencode(p_wvmid), rid=crate::apis::urlencode(p_rid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_bt_app_element_reference_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementReferenceInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementReferenceInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateReferenceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Request body parameters are multipart fields, so you must use `\"Content-Type\":\"multipart/form-data\"` in the request header.
pub async fn upload_blob_subelement(configuration: &configuration::Configuration, did: &str, wid: &str, eid: &str, bid: &str, transaction_id: Option<&str>, parent_change_id: Option<&str>, description: Option<&str>, file: Option<serde_json::Value>, file_content_length: Option<i64>) -> Result<models::BtAppElementModifyInfo, Error<UploadBlobSubelementError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_did = did;
    let p_wid = wid;
    let p_eid = eid;
    let p_bid = bid;
    let p_transaction_id = transaction_id;
    let p_parent_change_id = parent_change_id;
    let p_description = description;
    let p_file = file;
    let p_file_content_length = file_content_length;

    let uri_str = format!("{}/appelements/d/{did}/w/{wid}/e/{eid}/blob/{bid}", configuration.base_path, did=crate::apis::urlencode(p_did), wid=crate::apis::urlencode(p_wid), eid=crate::apis::urlencode(p_eid), bid=crate::apis::urlencode(p_bid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    if let Some(param_value) = p_transaction_id {
        multipart_form = multipart_form.text("transactionId", param_value.to_string());
    }
    if let Some(param_value) = p_parent_change_id {
        multipart_form = multipart_form.text("parentChangeId", param_value.to_string());
    }
    if let Some(param_value) = p_description {
        multipart_form = multipart_form.text("description", param_value.to_string());
    }
    if let Some(param_value) = p_file {
        multipart_form = multipart_form.text("file", param_value.to_string());
    }
    if let Some(param_value) = p_file_content_length {
        multipart_form = multipart_form.text("fileContentLength", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BtAppElementModifyInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BtAppElementModifyInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadBlobSubelementError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

